// Package flymachines provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package flymachines

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// Defines values for MachineHostStatus.
const (
	MachineHostStatusOk          MachineHostStatus = "ok"
	MachineHostStatusUnknown     MachineHostStatus = "unknown"
	MachineHostStatusUnreachable MachineHostStatus = "unreachable"
)

// Defines values for SignalRequestSignal.
const (
	SIGABRT SignalRequestSignal = "SIGABRT"
	SIGALRM SignalRequestSignal = "SIGALRM"
	SIGFPE  SignalRequestSignal = "SIGFPE"
	SIGHUP  SignalRequestSignal = "SIGHUP"
	SIGILL  SignalRequestSignal = "SIGILL"
	SIGINT  SignalRequestSignal = "SIGINT"
	SIGKILL SignalRequestSignal = "SIGKILL"
	SIGPIPE SignalRequestSignal = "SIGPIPE"
	SIGQUIT SignalRequestSignal = "SIGQUIT"
	SIGSEGV SignalRequestSignal = "SIGSEGV"
	SIGTERM SignalRequestSignal = "SIGTERM"
	SIGTRAP SignalRequestSignal = "SIGTRAP"
	SIGUSR1 SignalRequestSignal = "SIGUSR1"
)

// Defines values for VolumeHostStatus.
const (
	VolumeHostStatusOk          VolumeHostStatus = "ok"
	VolumeHostStatusUnknown     VolumeHostStatus = "unknown"
	VolumeHostStatusUnreachable VolumeHostStatus = "unreachable"
)

// Defines values for FlyContainerDependencyCondition.
const (
	FlyContainerDependencyConditionExitedSuccessfully FlyContainerDependencyCondition = "exited_successfully"
	FlyContainerDependencyConditionHealthy            FlyContainerDependencyCondition = "healthy"
	FlyContainerDependencyConditionStarted            FlyContainerDependencyCondition = "started"
)

// Defines values for FlyContainerHealthcheckKind.
const (
	FlyContainerHealthcheckKindLiveness  FlyContainerHealthcheckKind = "liveness"
	FlyContainerHealthcheckKindReadiness FlyContainerHealthcheckKind = "readiness"
)

// Defines values for FlyContainerHealthcheckScheme.
const (
	HTTP  FlyContainerHealthcheckScheme = "http"
	HTTPS FlyContainerHealthcheckScheme = "https"
)

// Defines values for FlyEnvFromFieldRef.
const (
	AppName   FlyEnvFromFieldRef = "app_name"
	Id        FlyEnvFromFieldRef = "id"
	Image     FlyEnvFromFieldRef = "image"
	PrivateIp FlyEnvFromFieldRef = "private_ip"
	Region    FlyEnvFromFieldRef = "region"
	Version   FlyEnvFromFieldRef = "version"
)

// Defines values for FlyMachineCheckKind.
const (
	FlyMachineCheckKindInformational FlyMachineCheckKind = "informational"
	FlyMachineCheckKindReadiness     FlyMachineCheckKind = "readiness"
)

// Defines values for FlyMachineRestartPolicy.
const (
	Always    FlyMachineRestartPolicy = "always"
	No        FlyMachineRestartPolicy = "no"
	OnFailure FlyMachineRestartPolicy = "on-failure"
	SpotPrice FlyMachineRestartPolicy = "spot-price"
)

// Defines values for FlyMachineServiceAutostop.
const (
	Off     FlyMachineServiceAutostop = "off"
	Stop    FlyMachineServiceAutostop = "stop"
	Suspend FlyMachineServiceAutostop = "suspend"
)

// Defines values for FlyUnhealthyPolicy.
const (
	UnhealthyPolicyStop FlyUnhealthyPolicy = "stop"
)

// Defines values for MainStatusCode.
const (
	CapacityErr MainStatusCode = "insufficient_capacity"
	Unknown     MainStatusCode = "unknown"
)

// Defines values for MachinesWaitParamsState.
const (
	MachinesWaitParamsStateDestroyed MachinesWaitParamsState = "destroyed"
	MachinesWaitParamsStateStarted   MachinesWaitParamsState = "started"
	MachinesWaitParamsStateStopped   MachinesWaitParamsState = "stopped"
	MachinesWaitParamsStateSuspended MachinesWaitParamsState = "suspended"
)

// App defines model for App.
type App struct {
	Id           *string       `json:"id,omitempty"`
	Name         *string       `json:"name,omitempty"`
	Organization *Organization `json:"organization,omitempty"`
	Status       *string       `json:"status,omitempty"`
}

// CheckStatus defines model for CheckStatus.
type CheckStatus struct {
	Name      *string `json:"name,omitempty"`
	Output    *string `json:"output,omitempty"`
	Status    *string `json:"status,omitempty"`
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// CreateAppRequest defines model for CreateAppRequest.
type CreateAppRequest struct {
	AppName          *string `json:"app_name,omitempty"`
	EnableSubdomains *bool   `json:"enable_subdomains,omitempty"`
	Network          *string `json:"network,omitempty"`
	OrgSlug          *string `json:"org_slug,omitempty"`
}

// CreateLeaseRequest defines model for CreateLeaseRequest.
type CreateLeaseRequest struct {
	Description *string `json:"description,omitempty"`

	// Ttl seconds lease will be valid
	Ttl *int `json:"ttl,omitempty"`
}

// CreateMachineRequest defines model for CreateMachineRequest.
type CreateMachineRequest struct {
	// Config An object defining the Machine configuration
	Config   *FlyMachineConfig `json:"config,omitempty"`
	LeaseTtl *int              `json:"lease_ttl,omitempty"`
	Lsvd     *bool             `json:"lsvd,omitempty"`

	// Name Unique name for this Machine. If omitted, one is generated for you
	Name *string `json:"name,omitempty"`

	// Region The target region. Omitting this param launches in the same region as your WireGuard peer connection (somewhere near you).
	Region                  *string `json:"region,omitempty"`
	SkipLaunch              *bool   `json:"skip_launch,omitempty"`
	SkipServiceRegistration *bool   `json:"skip_service_registration,omitempty"`
}

// CreateOIDCTokenRequest Optional parameters
type CreateOIDCTokenRequest struct {
	Aud *string `json:"aud,omitempty"`
}

// CreateSecretRequest defines model for CreateSecretRequest.
type CreateSecretRequest struct {
	Value *[]int `json:"value,omitempty"`
}

// CreateVolumeRequest defines model for CreateVolumeRequest.
type CreateVolumeRequest struct {
	Compute           *FlyMachineGuest `json:"compute,omitempty"`
	ComputeImage      *string          `json:"compute_image,omitempty"`
	Encrypted         *bool            `json:"encrypted,omitempty"`
	Fstype            *string          `json:"fstype,omitempty"`
	Name              *string          `json:"name,omitempty"`
	Region            *string          `json:"region,omitempty"`
	RequireUniqueZone *bool            `json:"require_unique_zone,omitempty"`
	SizeGb            *int             `json:"size_gb,omitempty"`

	// SnapshotId restore from snapshot
	SnapshotId        *string `json:"snapshot_id,omitempty"`
	SnapshotRetention *int    `json:"snapshot_retention,omitempty"`

	// SourceVolumeId fork from remote volume
	SourceVolumeId *string `json:"source_volume_id,omitempty"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Deprecated
	Details *map[string]interface{} `json:"details,omitempty"`
	Error   *string                 `json:"error,omitempty"`
	Status  *MainStatusCode         `json:"status,omitempty"`
}

// ExtendVolumeRequest defines model for ExtendVolumeRequest.
type ExtendVolumeRequest struct {
	SizeGb *int `json:"size_gb,omitempty"`
}

// ExtendVolumeResponse defines model for ExtendVolumeResponse.
type ExtendVolumeResponse struct {
	NeedsRestart *bool   `json:"needs_restart,omitempty"`
	Volume       *Volume `json:"volume,omitempty"`
}

// ImageRef defines model for ImageRef.
type ImageRef struct {
	Digest     *string            `json:"digest,omitempty"`
	Labels     *map[string]string `json:"labels,omitempty"`
	Registry   *string            `json:"registry,omitempty"`
	Repository *string            `json:"repository,omitempty"`
	Tag        *string            `json:"tag,omitempty"`
}

// Lease defines model for Lease.
type Lease struct {
	// Description Description or reason for the Lease.
	Description *string `json:"description,omitempty"`

	// ExpiresAt ExpiresAt is the unix timestamp in UTC to denote when the Lease will no longer be valid.
	ExpiresAt *int `json:"expires_at,omitempty"`

	// Nonce Nonce is the unique ID autogenerated and associated with the Lease.
	Nonce *string `json:"nonce,omitempty"`

	// Owner Owner is the user identifier which acquired the Lease.
	Owner *string `json:"owner,omitempty"`

	// Version Machine version
	Version *string `json:"version,omitempty"`
}

// ListApp defines model for ListApp.
type ListApp struct {
	Id           *string                 `json:"id,omitempty"`
	MachineCount *int                    `json:"machine_count,omitempty"`
	Name         *string                 `json:"name,omitempty"`
	Network      *map[string]interface{} `json:"network,omitempty"`
}

// ListAppsResponse defines model for ListAppsResponse.
type ListAppsResponse struct {
	Apps      *[]ListApp `json:"apps,omitempty"`
	TotalApps *int       `json:"total_apps,omitempty"`
}

// ListSecret defines model for ListSecret.
type ListSecret struct {
	Label     *string `json:"label,omitempty"`
	Publickey *[]int  `json:"publickey,omitempty"`
	Type      *string `json:"type,omitempty"`
}

// ListenSocket defines model for ListenSocket.
type ListenSocket struct {
	Address *string `json:"address,omitempty"`
	Proto   *string `json:"proto,omitempty"`
}

// Machine defines model for Machine.
type Machine struct {
	Checks           *[]CheckStatus     `json:"checks,omitempty"`
	Config           *FlyMachineConfig  `json:"config,omitempty"`
	CreatedAt        *string            `json:"created_at,omitempty"`
	Events           *[]MachineEvent    `json:"events,omitempty"`
	HostStatus       *MachineHostStatus `json:"host_status,omitempty"`
	Id               *string            `json:"id,omitempty"`
	ImageRef         *ImageRef          `json:"image_ref,omitempty"`
	IncompleteConfig *FlyMachineConfig  `json:"incomplete_config,omitempty"`

	// InstanceId InstanceID is unique for each version of the machine
	InstanceId *string `json:"instance_id,omitempty"`
	Name       *string `json:"name,omitempty"`

	// Nonce Nonce is only every returned on machine creation if a lease_duration was provided.
	Nonce *string `json:"nonce,omitempty"`

	// PrivateIp PrivateIP is the internal 6PN address of the machine.
	PrivateIp *string `json:"private_ip,omitempty"`
	Region    *string `json:"region,omitempty"`
	State     *string `json:"state,omitempty"`
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// MachineHostStatus defines model for Machine.HostStatus.
type MachineHostStatus string

// MachineEvent defines model for MachineEvent.
type MachineEvent struct {
	Id        *string                 `json:"id,omitempty"`
	Request   *map[string]interface{} `json:"request,omitempty"`
	Source    *string                 `json:"source,omitempty"`
	Status    *string                 `json:"status,omitempty"`
	Timestamp *int                    `json:"timestamp,omitempty"`
	Type      *string                 `json:"type,omitempty"`
}

// MachineExecRequest defines model for MachineExecRequest.
type MachineExecRequest struct {
	// Cmd Deprecated: use Command instead
	Cmd     *string   `json:"cmd,omitempty"`
	Command *[]string `json:"command,omitempty"`
	Timeout *int      `json:"timeout,omitempty"`
}

// MachineVersion defines model for MachineVersion.
type MachineVersion struct {
	UserConfig *FlyMachineConfig `json:"user_config,omitempty"`
	Version    *string           `json:"version,omitempty"`
}

// Organization defines model for Organization.
type Organization struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// ProcessStat defines model for ProcessStat.
type ProcessStat struct {
	Command       *string         `json:"command,omitempty"`
	Cpu           *int            `json:"cpu,omitempty"`
	Directory     *string         `json:"directory,omitempty"`
	ListenSockets *[]ListenSocket `json:"listen_sockets,omitempty"`
	Pid           *int            `json:"pid,omitempty"`
	Rss           *int            `json:"rss,omitempty"`
	Rtime         *int            `json:"rtime,omitempty"`
	Stime         *int            `json:"stime,omitempty"`
}

// SignalRequest defines model for SignalRequest.
type SignalRequest struct {
	Signal *SignalRequestSignal `json:"signal,omitempty"`
}

// SignalRequestSignal defines model for SignalRequest.Signal.
type SignalRequestSignal string

// StopRequest defines model for StopRequest.
type StopRequest struct {
	Signal  *string      `json:"signal,omitempty"`
	Timeout *FlyDuration `json:"timeout,omitempty"`
}

// UpdateMachineRequest defines model for UpdateMachineRequest.
type UpdateMachineRequest struct {
	// Config An object defining the Machine configuration
	Config         *FlyMachineConfig `json:"config,omitempty"`
	CurrentVersion *string           `json:"current_version,omitempty"`
	LeaseTtl       *int              `json:"lease_ttl,omitempty"`
	Lsvd           *bool             `json:"lsvd,omitempty"`

	// Name Unique name for this Machine. If omitted, one is generated for you
	Name *string `json:"name,omitempty"`

	// Region The target region. Omitting this param launches in the same region as your WireGuard peer connection (somewhere near you).
	Region                  *string `json:"region,omitempty"`
	SkipLaunch              *bool   `json:"skip_launch,omitempty"`
	SkipServiceRegistration *bool   `json:"skip_service_registration,omitempty"`
}

// UpdateVolumeRequest defines model for UpdateVolumeRequest.
type UpdateVolumeRequest struct {
	AutoBackupEnabled *bool `json:"auto_backup_enabled,omitempty"`
	SnapshotRetention *int  `json:"snapshot_retention,omitempty"`
}

// Volume defines model for Volume.
type Volume struct {
	AttachedAllocId   *string           `json:"attached_alloc_id,omitempty"`
	AttachedMachineId *string           `json:"attached_machine_id,omitempty"`
	AutoBackupEnabled *bool             `json:"auto_backup_enabled,omitempty"`
	BlockSize         *int              `json:"block_size,omitempty"`
	Blocks            *int              `json:"blocks,omitempty"`
	BlocksAvail       *int              `json:"blocks_avail,omitempty"`
	BlocksFree        *int              `json:"blocks_free,omitempty"`
	CreatedAt         *string           `json:"created_at,omitempty"`
	Encrypted         *bool             `json:"encrypted,omitempty"`
	Fstype            *string           `json:"fstype,omitempty"`
	HostStatus        *VolumeHostStatus `json:"host_status,omitempty"`
	Id                *string           `json:"id,omitempty"`
	Name              *string           `json:"name,omitempty"`
	Region            *string           `json:"region,omitempty"`
	SizeGb            *int              `json:"size_gb,omitempty"`
	SnapshotRetention *int              `json:"snapshot_retention,omitempty"`
	State             *string           `json:"state,omitempty"`
	Zone              *string           `json:"zone,omitempty"`
}

// VolumeHostStatus defines model for Volume.HostStatus.
type VolumeHostStatus string

// VolumeSnapshot defines model for VolumeSnapshot.
type VolumeSnapshot struct {
	CreatedAt     *string `json:"created_at,omitempty"`
	Digest        *string `json:"digest,omitempty"`
	Id            *string `json:"id,omitempty"`
	RetentionDays *int    `json:"retention_days,omitempty"`
	Size          *int    `json:"size,omitempty"`
	Status        *string `json:"status,omitempty"`
}

// FlyContainerConfig defines model for fly.ContainerConfig.
type FlyContainerConfig struct {
	// Cmd CmdOverride is used to override the default command of the image.
	Cmd *[]string `json:"cmd,omitempty"`

	// DependsOn DependsOn can be used to define dependencies between containers. The container will only be
	// started after all of its dependent conditions have been satisfied.
	DependsOn *[]FlyContainerDependency `json:"depends_on,omitempty"`

	// Entrypoint EntrypointOverride is used to override the default entrypoint of the image.
	Entrypoint *[]string `json:"entrypoint,omitempty"`

	// Env ExtraEnv is used to add additional environment variables to the container.
	Env *map[string]string `json:"env,omitempty"`

	// EnvFrom EnvFrom can be provided to set environment variables from machine fields.
	EnvFrom *[]FlyEnvFrom `json:"env_from,omitempty"`

	// Exec Image Config overrides - these fields are used to override the image configuration.
	// If not provided, the image configuration will be used.
	// ExecOverride is used to override the default command of the image.
	Exec *[]string `json:"exec,omitempty"`

	// Files Files are files that will be written to the container file system.
	Files *[]FlyFile `json:"files,omitempty"`

	// Healthchecks Healthchecks determine the health of your containers. Healthchecks can use HTTP, TCP or an Exec command.
	Healthchecks *[]FlyContainerHealthcheck `json:"healthchecks,omitempty"`

	// Image Image is the docker image to run.
	Image *string `json:"image,omitempty"`

	// Mounts Set of mounts added to the container. These must reference a volume in the machine config via its name.
	Mounts *[]FlyContainerMount `json:"mounts,omitempty"`

	// Name Name is used to identify the container in the machine.
	Name *string `json:"name,omitempty"`

	// Restart Restart is used to define the restart policy for the container. NOTE: spot-price is not
	// supported for containers.
	Restart *FlyMachineRestart `json:"restart,omitempty"`

	// Secrets Secrets can be provided at the process level to explicitly indicate which secrets should be
	// used for the process. If not provided, the secrets provided at the machine level will be used.
	Secrets *[]FlyMachineSecret `json:"secrets,omitempty"`

	// Stop Stop is used to define the signal and timeout for stopping the container.
	Stop *FlyStopConfig `json:"stop,omitempty"`

	// User UserOverride is used to override the default user of the image.
	User *string `json:"user,omitempty"`
}

// FlyContainerDependency defines model for fly.ContainerDependency.
type FlyContainerDependency struct {
	Condition *FlyContainerDependencyCondition `json:"condition,omitempty"`
	Name      *string                          `json:"name,omitempty"`
}

// FlyContainerDependencyCondition defines model for fly.ContainerDependencyCondition.
type FlyContainerDependencyCondition string

// FlyContainerHealthcheck defines model for fly.ContainerHealthcheck.
type FlyContainerHealthcheck struct {
	Exec *FlyExecHealthcheck `json:"exec,omitempty"`

	// FailureThreshold The number of times the check must fail before considering the container unhealthy.
	FailureThreshold *int `json:"failure_threshold,omitempty"`

	// GracePeriod The time in seconds to wait after a container starts before checking its health.
	GracePeriod *int                `json:"grace_period,omitempty"`
	Http        *FlyHTTPHealthcheck `json:"http,omitempty"`

	// Interval The time in seconds between executing the defined check.
	Interval *int `json:"interval,omitempty"`

	// Kind Kind of healthcheck (readiness, liveness)
	Kind *FlyContainerHealthcheckKind `json:"kind,omitempty"`

	// Name The name of the check. Must be unique within the container.
	Name *string `json:"name,omitempty"`

	// SuccessThreshold The number of times the check must succeeed before considering the container healthy.
	SuccessThreshold *int               `json:"success_threshold,omitempty"`
	Tcp              *FlyTCPHealthcheck `json:"tcp,omitempty"`

	// Timeout The time in seconds to wait for the check to complete.
	Timeout *int `json:"timeout,omitempty"`

	// Unhealthy Unhealthy policy that determines what action to take if a container is deemed unhealthy
	Unhealthy *FlyUnhealthyPolicy `json:"unhealthy,omitempty"`
}

// FlyContainerHealthcheckKind defines model for fly.ContainerHealthcheckKind.
type FlyContainerHealthcheckKind string

// FlyContainerHealthcheckScheme defines model for fly.ContainerHealthcheckScheme.
type FlyContainerHealthcheckScheme string

// FlyContainerMount defines model for fly.ContainerMount.
type FlyContainerMount struct {
	// Name The name of the volume. Must exist in the volumes field in the machine configuration
	Name *string `json:"name,omitempty"`

	// Path The path to mount the volume within the container
	Path *string `json:"path,omitempty"`
}

// FlyDNSConfig defines model for fly.DNSConfig.
type FlyDNSConfig struct {
	DnsForwardRules  *[]FlyDnsForwardRule `json:"dns_forward_rules,omitempty"`
	Hostname         *string              `json:"hostname,omitempty"`
	HostnameFqdn     *string              `json:"hostname_fqdn,omitempty"`
	Nameservers      *[]string            `json:"nameservers,omitempty"`
	Options          *[]FlyDnsOption      `json:"options,omitempty"`
	Searches         *[]string            `json:"searches,omitempty"`
	SkipRegistration *bool                `json:"skip_registration,omitempty"`
}

// FlyDuration defines model for fly.Duration.
type FlyDuration struct {
	TimeDuration *int `json:"time.Duration,omitempty"`
}

// FlyEnvFrom EnvVar defines an environment variable to be populated from a machine field, env_var
type FlyEnvFrom struct {
	// EnvVar EnvVar is required and is the name of the environment variable that will be set from the
	// secret. It must be a valid environment variable name.
	EnvVar *string `json:"env_var,omitempty"`

	// FieldRef FieldRef selects a field of the Machine: supports id, version, app_name, private_ip, region, image.
	FieldRef *FlyEnvFromFieldRef `json:"field_ref,omitempty"`
}

// FlyEnvFromFieldRef FieldRef selects a field of the Machine: supports id, version, app_name, private_ip, region, image.
type FlyEnvFromFieldRef string

// FlyExecHealthcheck defines model for fly.ExecHealthcheck.
type FlyExecHealthcheck struct {
	// Command The command to run to check the health of the container (e.g. ["cat", "/tmp/healthy"])
	Command *[]string `json:"command,omitempty"`
}

// FlyFile A file that will be written to the Machine. One of RawValue or SecretName must be set.
type FlyFile struct {
	// GuestPath GuestPath is the path on the machine where the file will be written and must be an absolute path.
	// For example: /full/path/to/file.json
	GuestPath *string `json:"guest_path,omitempty"`

	// Mode Mode bits used to set permissions on this file as accepted by chmod(2).
	Mode *int `json:"mode,omitempty"`

	// RawValue The base64 encoded string of the file contents.
	RawValue *string `json:"raw_value,omitempty"`

	// SecretName The name of the secret that contains the base64 encoded file contents.
	SecretName *string `json:"secret_name,omitempty"`
}

// FlyHTTPHealthcheck defines model for fly.HTTPHealthcheck.
type FlyHTTPHealthcheck struct {
	// Headers Additional headers to send with the request
	Headers *[]FlyMachineHTTPHeader `json:"headers,omitempty"`

	// Method The HTTP method to use to when making the request
	Method *string `json:"method,omitempty"`

	// Path The path to send the request to
	Path *string `json:"path,omitempty"`

	// Port The port to connect to, often the same as internal_port
	Port *int `json:"port,omitempty"`

	// Scheme Whether to use http or https
	Scheme *FlyContainerHealthcheckScheme `json:"scheme,omitempty"`

	// TlsServerName If the protocol is https, the hostname to use for TLS certificate validation
	TlsServerName *string `json:"tls_server_name,omitempty"`

	// TlsSkipVerify If the protocol is https, whether or not to verify the TLS certificate
	TlsSkipVerify *bool `json:"tls_skip_verify,omitempty"`
}

// FlyHTTPOptions defines model for fly.HTTPOptions.
type FlyHTTPOptions struct {
	Compress           *bool                   `json:"compress,omitempty"`
	H2Backend          *bool                   `json:"h2_backend,omitempty"`
	HeadersReadTimeout *int                    `json:"headers_read_timeout,omitempty"`
	IdleTimeout        *int                    `json:"idle_timeout,omitempty"`
	Response           *FlyHTTPResponseOptions `json:"response,omitempty"`
}

// FlyHTTPResponseOptions defines model for fly.HTTPResponseOptions.
type FlyHTTPResponseOptions struct {
	Headers  *map[string]map[string]interface{} `json:"headers,omitempty"`
	Pristine *bool                              `json:"pristine,omitempty"`
}

// FlyMachineCheck An optional object that defines one or more named checks. The key for each check is the check name.
type FlyMachineCheck struct {
	// GracePeriod The time to wait after a VM starts before checking its health
	GracePeriod *FlyDuration            `json:"grace_period,omitempty"`
	Headers     *[]FlyMachineHTTPHeader `json:"headers,omitempty"`

	// Interval The time between connectivity checks
	Interval *string `json:"interval,omitempty"`

	// Kind Kind of the check (informational, readiness)
	Kind *FlyMachineCheckKind `json:"kind,omitempty"`

	// Method For http checks, the HTTP method to use to when making the request
	Method *string `json:"method,omitempty"`

	// Path For http checks, the path to send the request to
	Path *string `json:"path,omitempty"`

	// Port The port to connect to, often the same as internal_port
	Port *int `json:"port,omitempty"`

	// Protocol For http checks, whether to use http or https
	Protocol *string `json:"protocol,omitempty"`

	// Timeout The maximum time a connection can take before being reported as failing its health check
	Timeout *string `json:"timeout,omitempty"`

	// TlsServerName If the protocol is https, the hostname to use for TLS certificate validation
	TlsServerName *string `json:"tls_server_name,omitempty"`

	// TlsSkipVerify For http checks with https protocol, whether or not to verify the TLS certificate
	TlsSkipVerify *bool `json:"tls_skip_verify,omitempty"`

	// Type tcp or http
	Type *string `json:"type,omitempty"`
}

// FlyMachineCheckKind Kind of the check (informational, readiness)
type FlyMachineCheckKind string

// FlyMachineConfig defines model for fly.MachineConfig.
type FlyMachineConfig struct {
	// AutoDestroy Optional boolean telling the Machine to destroy itself once it’s complete (default false)
	AutoDestroy *bool                       `json:"auto_destroy,omitempty"`
	Checks      *map[string]FlyMachineCheck `json:"checks,omitempty"`

	// Containers Containers are a list of containers that will run in the machine. Currently restricted to
	// only specific organizations.
	Containers *[]FlyContainerConfig `json:"containers,omitempty"`

	// DisableMachineAutostart Deprecated: use Service.Autostart instead
	DisableMachineAutostart *bool         `json:"disable_machine_autostart,omitempty"`
	Dns                     *FlyDNSConfig `json:"dns,omitempty"`

	// Env An object filled with key/value pairs to be set as environment variables
	Env   *map[string]string `json:"env,omitempty"`
	Files *[]FlyFile         `json:"files,omitempty"`
	Guest *FlyMachineGuest   `json:"guest,omitempty"`

	// Image The docker image to run
	Image     *string              `json:"image,omitempty"`
	Init      *FlyMachineInit      `json:"init,omitempty"`
	Metadata  *map[string]string   `json:"metadata,omitempty"`
	Metrics   *FlyMachineMetrics   `json:"metrics,omitempty"`
	Mounts    *[]FlyMachineMount   `json:"mounts,omitempty"`
	Processes *[]FlyMachineProcess `json:"processes,omitempty"`

	// Restart The Machine restart policy defines whether and how flyd restarts a Machine after its main process exits. See https://fly.io/docs/machines/guides-examples/machine-restart-policy/.
	Restart  *FlyMachineRestart   `json:"restart,omitempty"`
	Schedule *string              `json:"schedule,omitempty"`
	Services *[]FlyMachineService `json:"services,omitempty"`

	// Size Deprecated: use Guest instead
	Size *string `json:"size,omitempty"`

	// Standbys Standbys enable a machine to be a standby for another. In the event of a hardware failure,
	// the standby machine will be started.
	Standbys   *[]string      `json:"standbys,omitempty"`
	Statics    *[]FlyStatic   `json:"statics,omitempty"`
	StopConfig *FlyStopConfig `json:"stop_config,omitempty"`

	// Volumes Volumes describe the set of volumes that can be attached to the machine. Used in conjuction
	// with containers
	Volumes *[]FlyVolumeConfig `json:"volumes,omitempty"`
}

// FlyMachineGuest defines model for fly.MachineGuest.
type FlyMachineGuest struct {
	CpuKind          *string   `json:"cpu_kind,omitempty"`
	Cpus             *int      `json:"cpus,omitempty"`
	GpuKind          *string   `json:"gpu_kind,omitempty"`
	Gpus             *int      `json:"gpus,omitempty"`
	HostDedicationId *string   `json:"host_dedication_id,omitempty"`
	KernelArgs       *[]string `json:"kernel_args,omitempty"`
	MemoryMb         *int      `json:"memory_mb,omitempty"`
}

// FlyMachineHTTPHeader For http checks, an array of objects with string field Name and array of strings field Values. The key/value pairs specify header and header values that will get passed with the check call.
type FlyMachineHTTPHeader struct {
	// Name The header name
	Name *string `json:"name,omitempty"`

	// Values The header value
	Values *[]string `json:"values,omitempty"`
}

// FlyMachineInit defines model for fly.MachineInit.
type FlyMachineInit struct {
	Cmd        *[]string `json:"cmd,omitempty"`
	Entrypoint *[]string `json:"entrypoint,omitempty"`
	Exec       *[]string `json:"exec,omitempty"`
	KernelArgs *[]string `json:"kernel_args,omitempty"`
	SwapSizeMb *int      `json:"swap_size_mb,omitempty"`
	Tty        *bool     `json:"tty,omitempty"`
}

// FlyMachineMetrics defines model for fly.MachineMetrics.
type FlyMachineMetrics struct {
	Https *bool   `json:"https,omitempty"`
	Path  *string `json:"path,omitempty"`
	Port  *int    `json:"port,omitempty"`
}

// FlyMachineMount defines model for fly.MachineMount.
type FlyMachineMount struct {
	AddSizeGb              *int    `json:"add_size_gb,omitempty"`
	Encrypted              *bool   `json:"encrypted,omitempty"`
	ExtendThresholdPercent *int    `json:"extend_threshold_percent,omitempty"`
	Name                   *string `json:"name,omitempty"`
	Path                   *string `json:"path,omitempty"`
	SizeGb                 *int    `json:"size_gb,omitempty"`
	SizeGbLimit            *int    `json:"size_gb_limit,omitempty"`
	Volume                 *string `json:"volume,omitempty"`
}

// FlyMachinePort defines model for fly.MachinePort.
type FlyMachinePort struct {
	EndPort           *int                  `json:"end_port,omitempty"`
	ForceHttps        *bool                 `json:"force_https,omitempty"`
	Handlers          *[]string             `json:"handlers,omitempty"`
	HttpOptions       *FlyHTTPOptions       `json:"http_options,omitempty"`
	Port              *int                  `json:"port,omitempty"`
	ProxyProtoOptions *FlyProxyProtoOptions `json:"proxy_proto_options,omitempty"`
	StartPort         *int                  `json:"start_port,omitempty"`
	TlsOptions        *FlyTLSOptions        `json:"tls_options,omitempty"`
}

// FlyMachineProcess defines model for fly.MachineProcess.
type FlyMachineProcess struct {
	Cmd        *[]string          `json:"cmd,omitempty"`
	Entrypoint *[]string          `json:"entrypoint,omitempty"`
	Env        *map[string]string `json:"env,omitempty"`

	// EnvFrom EnvFrom can be provided to set environment variables from machine fields.
	EnvFrom *[]FlyEnvFrom `json:"env_from,omitempty"`
	Exec    *[]string     `json:"exec,omitempty"`

	// IgnoreAppSecrets IgnoreAppSecrets can be set to true to ignore the secrets for the App the Machine belongs to
	// and only use the secrets provided at the process level. The default/legacy behavior is to use
	// the secrets provided at the App level.
	IgnoreAppSecrets *bool `json:"ignore_app_secrets,omitempty"`

	// Secrets Secrets can be provided at the process level to explicitly indicate which secrets should be
	// used for the process. If not provided, the secrets provided at the machine level will be used.
	Secrets *[]FlyMachineSecret `json:"secrets,omitempty"`
	User    *string             `json:"user,omitempty"`
}

// FlyMachineRestart The Machine restart policy defines whether and how flyd restarts a Machine after its main process exits. See https://fly.io/docs/machines/guides-examples/machine-restart-policy/.
type FlyMachineRestart struct {
	// GpuBidPrice GPU bid price for spot Machines.
	GpuBidPrice *float32 `json:"gpu_bid_price,omitempty"`

	// MaxRetries When policy is on-failure, the maximum number of times to attempt to restart the Machine before letting it stop.
	MaxRetries *int `json:"max_retries,omitempty"`

	// Policy * no - Never try to restart a Machine automatically when its main process exits, whether that’s on purpose or on a crash.
	// * always - Always restart a Machine automatically and never let it enter a stopped state, even when the main process exits cleanly.
	// * on-failure - Try up to MaxRetries times to automatically restart the Machine if it exits with a non-zero exit code. Default when no explicit policy is set, and for Machines with schedules.
	// * spot-price - Starts the Machine only when there is capacity and the spot price is less than or equal to the bid price.
	Policy *FlyMachineRestartPolicy `json:"policy,omitempty"`
}

// FlyMachineRestartPolicy * no - Never try to restart a Machine automatically when its main process exits, whether that’s on purpose or on a crash.
// * always - Always restart a Machine automatically and never let it enter a stopped state, even when the main process exits cleanly.
// * on-failure - Try up to MaxRetries times to automatically restart the Machine if it exits with a non-zero exit code. Default when no explicit policy is set, and for Machines with schedules.
// * spot-price - Starts the Machine only when there is capacity and the spot price is less than or equal to the bid price.
type FlyMachineRestartPolicy string

// FlyMachineSecret A Secret needing to be set in the environment of the Machine. env_var is required
type FlyMachineSecret struct {
	// EnvVar EnvVar is required and is the name of the environment variable that will be set from the
	// secret. It must be a valid environment variable name.
	EnvVar *string `json:"env_var,omitempty"`

	// Name Name is optional and when provided is used to reference a secret name where the EnvVar is
	// different from what was set as the secret name.
	Name *string `json:"name,omitempty"`
}

// FlyMachineService defines model for fly.MachineService.
type FlyMachineService struct {
	Autostart *bool `json:"autostart,omitempty"`

	// Autostop Accepts a string (new format) or a boolean (old format). For backward compatibility with older clients, the API continues to use booleans for "off" and "stop" in responses.
	// * "off" or false - Do not autostop the Machine.
	// * "stop" or true - Automatically stop the Machine.
	// * "suspend" - Automatically suspend the Machine, falling back to a full stop if this is not possible.
	Autostop                 *FlyMachineServiceAutostop    `json:"autostop,omitempty"`
	Checks                   *[]FlyMachineCheck            `json:"checks,omitempty"`
	Concurrency              *FlyMachineServiceConcurrency `json:"concurrency,omitempty"`
	ForceInstanceDescription *string                       `json:"force_instance_description,omitempty"`
	ForceInstanceKey         *string                       `json:"force_instance_key,omitempty"`
	InternalPort             *int                          `json:"internal_port,omitempty"`
	MinMachinesRunning       *int                          `json:"min_machines_running,omitempty"`
	Ports                    *[]FlyMachinePort             `json:"ports,omitempty"`
	Protocol                 *string                       `json:"protocol,omitempty"`
}

// FlyMachineServiceAutostop Accepts a string (new format) or a boolean (old format). For backward compatibility with older clients, the API continues to use booleans for "off" and "stop" in responses.
// * "off" or false - Do not autostop the Machine.
// * "stop" or true - Automatically stop the Machine.
// * "suspend" - Automatically suspend the Machine, falling back to a full stop if this is not possible.
type FlyMachineServiceAutostop string

// FlyMachineServiceConcurrency defines model for fly.MachineServiceConcurrency.
type FlyMachineServiceConcurrency struct {
	HardLimit *int    `json:"hard_limit,omitempty"`
	SoftLimit *int    `json:"soft_limit,omitempty"`
	Type      *string `json:"type,omitempty"`
}

// FlyProxyProtoOptions defines model for fly.ProxyProtoOptions.
type FlyProxyProtoOptions struct {
	Version *string `json:"version,omitempty"`
}

// FlyStatic defines model for fly.Static.
type FlyStatic struct {
	GuestPath     string  `json:"guest_path"`
	IndexDocument *string `json:"index_document,omitempty"`
	TigrisBucket  *string `json:"tigris_bucket,omitempty"`
	UrlPrefix     string  `json:"url_prefix"`
}

// FlyStopConfig defines model for fly.StopConfig.
type FlyStopConfig struct {
	Signal  *string      `json:"signal,omitempty"`
	Timeout *FlyDuration `json:"timeout,omitempty"`
}

// FlyTCPHealthcheck defines model for fly.TCPHealthcheck.
type FlyTCPHealthcheck struct {
	// Port The port to connect to, often the same as internal_port
	Port *int `json:"port,omitempty"`
}

// FlyTLSOptions defines model for fly.TLSOptions.
type FlyTLSOptions struct {
	Alpn              *[]string `json:"alpn,omitempty"`
	DefaultSelfSigned *bool     `json:"default_self_signed,omitempty"`
	Versions          *[]string `json:"versions,omitempty"`
}

// FlyTempDirVolume defines model for fly.TempDirVolume.
type FlyTempDirVolume struct {
	// SizeMb The size limit of the temp dir, only applicable when using disk backed storage.
	SizeMb *int `json:"size_mb,omitempty"`

	// StorageType The type of storage used to back the temp dir. Either disk or memory.
	StorageType *string `json:"storage_type,omitempty"`
}

// FlyUnhealthyPolicy defines model for fly.UnhealthyPolicy.
type FlyUnhealthyPolicy string

// FlyVolumeConfig defines model for fly.VolumeConfig.
type FlyVolumeConfig struct {
	// Name The name of the volume. A volume must have a unique name within an app
	Name    *string           `json:"name,omitempty"`
	TempDir *FlyTempDirVolume `json:"temp_dir,omitempty"`
}

// FlyDnsForwardRule defines model for fly.dnsForwardRule.
type FlyDnsForwardRule struct {
	Addr     *string `json:"addr,omitempty"`
	Basename *string `json:"basename,omitempty"`
}

// FlyDnsOption defines model for fly.dnsOption.
type FlyDnsOption struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// Flydv1ExecResponse defines model for flydv1.ExecResponse.
type Flydv1ExecResponse struct {
	ExitCode   *int    `json:"exit_code,omitempty"`
	ExitSignal *int    `json:"exit_signal,omitempty"`
	Stderr     *string `json:"stderr,omitempty"`
	Stdout     *string `json:"stdout,omitempty"`
}

// MainStatusCode defines model for main.statusCode.
type MainStatusCode string

// AppsListParams defines parameters for AppsList.
type AppsListParams struct {
	// OrgSlug The org slug, or 'personal', to filter apps
	OrgSlug string `form:"org_slug" json:"org_slug"`
}

// MachinesListParams defines parameters for MachinesList.
type MachinesListParams struct {
	// IncludeDeleted Include deleted machines
	IncludeDeleted *bool `form:"include_deleted,omitempty" json:"include_deleted,omitempty"`

	// Region Region filter
	Region *string `form:"region,omitempty" json:"region,omitempty"`

	// State comma separated list of states to filter (created, started, stopped, suspended)
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// Summary Only return summary info about machines (omit config, checks, events, host_status, nonce, etc.)
	Summary *bool `form:"summary,omitempty" json:"summary,omitempty"`
}

// MachinesDeleteParams defines parameters for MachinesDelete.
type MachinesDeleteParams struct {
	// Force Force kill the machine if it's running
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// MachinesReleaseLeaseParams defines parameters for MachinesReleaseLease.
type MachinesReleaseLeaseParams struct {
	// FlyMachineLeaseNonce Existing lease nonce
	FlyMachineLeaseNonce string `json:"fly-machine-lease-nonce"`
}

// MachinesCreateLeaseParams defines parameters for MachinesCreateLease.
type MachinesCreateLeaseParams struct {
	// FlyMachineLeaseNonce Existing lease nonce to refresh by ttl, empty or non-existent to create a new lease
	FlyMachineLeaseNonce *string `json:"fly-machine-lease-nonce,omitempty"`
}

// MachinesListProcessesParams defines parameters for MachinesListProcesses.
type MachinesListProcessesParams struct {
	// SortBy Sort by
	SortBy *string `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// Order Order
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// MachinesRestartParams defines parameters for MachinesRestart.
type MachinesRestartParams struct {
	// Timeout Restart timeout as a Go duration string or number of seconds
	Timeout *string `form:"timeout,omitempty" json:"timeout,omitempty"`

	// Signal Unix signal name
	Signal *string `form:"signal,omitempty" json:"signal,omitempty"`
}

// MachinesWaitParams defines parameters for MachinesWait.
type MachinesWaitParams struct {
	// InstanceId 26-character Machine version ID
	InstanceId *string `form:"instance_id,omitempty" json:"instance_id,omitempty"`

	// Timeout wait timeout. default 60s
	Timeout *int `form:"timeout,omitempty" json:"timeout,omitempty"`

	// State desired state
	State *MachinesWaitParamsState `form:"state,omitempty" json:"state,omitempty"`
}

// MachinesWaitParamsState defines parameters for MachinesWait.
type MachinesWaitParamsState string

// VolumesListParams defines parameters for VolumesList.
type VolumesListParams struct {
	// Summary Only return summary info about volumes (omit blocks, block size, etc)
	Summary *bool `form:"summary,omitempty" json:"summary,omitempty"`
}

// AppsCreateJSONRequestBody defines body for AppsCreate for application/json ContentType.
type AppsCreateJSONRequestBody = CreateAppRequest

// MachinesCreateJSONRequestBody defines body for MachinesCreate for application/json ContentType.
type MachinesCreateJSONRequestBody = CreateMachineRequest

// MachinesUpdateJSONRequestBody defines body for MachinesUpdate for application/json ContentType.
type MachinesUpdateJSONRequestBody = UpdateMachineRequest

// MachinesExecJSONRequestBody defines body for MachinesExec for application/json ContentType.
type MachinesExecJSONRequestBody = MachineExecRequest

// MachinesCreateLeaseJSONRequestBody defines body for MachinesCreateLease for application/json ContentType.
type MachinesCreateLeaseJSONRequestBody = CreateLeaseRequest

// MachinesSignalJSONRequestBody defines body for MachinesSignal for application/json ContentType.
type MachinesSignalJSONRequestBody = SignalRequest

// MachinesStopJSONRequestBody defines body for MachinesStop for application/json ContentType.
type MachinesStopJSONRequestBody = StopRequest

// SecretCreateJSONRequestBody defines body for SecretCreate for application/json ContentType.
type SecretCreateJSONRequestBody = CreateSecretRequest

// VolumesCreateJSONRequestBody defines body for VolumesCreate for application/json ContentType.
type VolumesCreateJSONRequestBody = CreateVolumeRequest

// VolumesUpdateJSONRequestBody defines body for VolumesUpdate for application/json ContentType.
type VolumesUpdateJSONRequestBody = UpdateVolumeRequest

// VolumesExtendJSONRequestBody defines body for VolumesExtend for application/json ContentType.
type VolumesExtendJSONRequestBody = ExtendVolumeRequest

// TokensRequestOIDCJSONRequestBody defines body for TokensRequestOIDC for application/json ContentType.
type TokensRequestOIDCJSONRequestBody = CreateOIDCTokenRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AppsList request
	AppsList(ctx context.Context, params *AppsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsCreateWithBody request with any body
	AppsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppsCreate(ctx context.Context, body AppsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsDelete request
	AppsDelete(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsShow request
	AppsShow(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesList request
	MachinesList(ctx context.Context, appName string, params *MachinesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesCreateWithBody request with any body
	MachinesCreateWithBody(ctx context.Context, appName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MachinesCreate(ctx context.Context, appName string, body MachinesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesDelete request
	MachinesDelete(ctx context.Context, appName string, machineId string, params *MachinesDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesShow request
	MachinesShow(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesUpdateWithBody request with any body
	MachinesUpdateWithBody(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MachinesUpdate(ctx context.Context, appName string, machineId string, body MachinesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesCordon request
	MachinesCordon(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesListEvents request
	MachinesListEvents(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesExecWithBody request with any body
	MachinesExecWithBody(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MachinesExec(ctx context.Context, appName string, machineId string, body MachinesExecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesReleaseLease request
	MachinesReleaseLease(ctx context.Context, appName string, machineId string, params *MachinesReleaseLeaseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesShowLease request
	MachinesShowLease(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesCreateLeaseWithBody request with any body
	MachinesCreateLeaseWithBody(ctx context.Context, appName string, machineId string, params *MachinesCreateLeaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MachinesCreateLease(ctx context.Context, appName string, machineId string, params *MachinesCreateLeaseParams, body MachinesCreateLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesShowMetadata request
	MachinesShowMetadata(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesDeleteMetadata request
	MachinesDeleteMetadata(ctx context.Context, appName string, machineId string, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesUpdateMetadata request
	MachinesUpdateMetadata(ctx context.Context, appName string, machineId string, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesListProcesses request
	MachinesListProcesses(ctx context.Context, appName string, machineId string, params *MachinesListProcessesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesRestart request
	MachinesRestart(ctx context.Context, appName string, machineId string, params *MachinesRestartParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesSignalWithBody request with any body
	MachinesSignalWithBody(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MachinesSignal(ctx context.Context, appName string, machineId string, body MachinesSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesStart request
	MachinesStart(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesStopWithBody request with any body
	MachinesStopWithBody(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MachinesStop(ctx context.Context, appName string, machineId string, body MachinesStopJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesSuspend request
	MachinesSuspend(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesUncordon request
	MachinesUncordon(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesListVersions request
	MachinesListVersions(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MachinesWait request
	MachinesWait(ctx context.Context, appName string, machineId string, params *MachinesWaitParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SecretsList request
	SecretsList(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SecretDelete request
	SecretDelete(ctx context.Context, appName string, secretLabel string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SecretCreateWithBody request with any body
	SecretCreateWithBody(ctx context.Context, appName string, secretLabel string, secretType string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SecretCreate(ctx context.Context, appName string, secretLabel string, secretType string, body SecretCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SecretGenerate request
	SecretGenerate(ctx context.Context, appName string, secretLabel string, secretType string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VolumesList request
	VolumesList(ctx context.Context, appName string, params *VolumesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VolumesCreateWithBody request with any body
	VolumesCreateWithBody(ctx context.Context, appName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VolumesCreate(ctx context.Context, appName string, body VolumesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VolumeDelete request
	VolumeDelete(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VolumesGetById request
	VolumesGetById(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VolumesUpdateWithBody request with any body
	VolumesUpdateWithBody(ctx context.Context, appName string, volumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VolumesUpdate(ctx context.Context, appName string, volumeId string, body VolumesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VolumesExtendWithBody request with any body
	VolumesExtendWithBody(ctx context.Context, appName string, volumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VolumesExtend(ctx context.Context, appName string, volumeId string, body VolumesExtendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VolumesListSnapshots request
	VolumesListSnapshots(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVolumeSnapshot request
	CreateVolumeSnapshot(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TokensRequestKms request
	TokensRequestKms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TokensRequestOIDCWithBody request with any body
	TokensRequestOIDCWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TokensRequestOIDC(ctx context.Context, body TokensRequestOIDCJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AppsList(ctx context.Context, params *AppsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsCreate(ctx context.Context, body AppsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsDelete(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsDeleteRequest(c.Server, appName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsShow(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsShowRequest(c.Server, appName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesList(ctx context.Context, appName string, params *MachinesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesListRequest(c.Server, appName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesCreateWithBody(ctx context.Context, appName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesCreateRequestWithBody(c.Server, appName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesCreate(ctx context.Context, appName string, body MachinesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesCreateRequest(c.Server, appName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesDelete(ctx context.Context, appName string, machineId string, params *MachinesDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesDeleteRequest(c.Server, appName, machineId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesShow(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesShowRequest(c.Server, appName, machineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesUpdateWithBody(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesUpdateRequestWithBody(c.Server, appName, machineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesUpdate(ctx context.Context, appName string, machineId string, body MachinesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesUpdateRequest(c.Server, appName, machineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesCordon(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesCordonRequest(c.Server, appName, machineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesListEvents(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesListEventsRequest(c.Server, appName, machineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesExecWithBody(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesExecRequestWithBody(c.Server, appName, machineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesExec(ctx context.Context, appName string, machineId string, body MachinesExecJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesExecRequest(c.Server, appName, machineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesReleaseLease(ctx context.Context, appName string, machineId string, params *MachinesReleaseLeaseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesReleaseLeaseRequest(c.Server, appName, machineId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesShowLease(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesShowLeaseRequest(c.Server, appName, machineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesCreateLeaseWithBody(ctx context.Context, appName string, machineId string, params *MachinesCreateLeaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesCreateLeaseRequestWithBody(c.Server, appName, machineId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesCreateLease(ctx context.Context, appName string, machineId string, params *MachinesCreateLeaseParams, body MachinesCreateLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesCreateLeaseRequest(c.Server, appName, machineId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesShowMetadata(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesShowMetadataRequest(c.Server, appName, machineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesDeleteMetadata(ctx context.Context, appName string, machineId string, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesDeleteMetadataRequest(c.Server, appName, machineId, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesUpdateMetadata(ctx context.Context, appName string, machineId string, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesUpdateMetadataRequest(c.Server, appName, machineId, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesListProcesses(ctx context.Context, appName string, machineId string, params *MachinesListProcessesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesListProcessesRequest(c.Server, appName, machineId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesRestart(ctx context.Context, appName string, machineId string, params *MachinesRestartParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesRestartRequest(c.Server, appName, machineId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesSignalWithBody(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesSignalRequestWithBody(c.Server, appName, machineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesSignal(ctx context.Context, appName string, machineId string, body MachinesSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesSignalRequest(c.Server, appName, machineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesStart(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesStartRequest(c.Server, appName, machineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesStopWithBody(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesStopRequestWithBody(c.Server, appName, machineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesStop(ctx context.Context, appName string, machineId string, body MachinesStopJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesStopRequest(c.Server, appName, machineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesSuspend(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesSuspendRequest(c.Server, appName, machineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesUncordon(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesUncordonRequest(c.Server, appName, machineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesListVersions(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesListVersionsRequest(c.Server, appName, machineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MachinesWait(ctx context.Context, appName string, machineId string, params *MachinesWaitParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMachinesWaitRequest(c.Server, appName, machineId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SecretsList(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSecretsListRequest(c.Server, appName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SecretDelete(ctx context.Context, appName string, secretLabel string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSecretDeleteRequest(c.Server, appName, secretLabel)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SecretCreateWithBody(ctx context.Context, appName string, secretLabel string, secretType string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSecretCreateRequestWithBody(c.Server, appName, secretLabel, secretType, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SecretCreate(ctx context.Context, appName string, secretLabel string, secretType string, body SecretCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSecretCreateRequest(c.Server, appName, secretLabel, secretType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SecretGenerate(ctx context.Context, appName string, secretLabel string, secretType string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSecretGenerateRequest(c.Server, appName, secretLabel, secretType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumesList(ctx context.Context, appName string, params *VolumesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumesListRequest(c.Server, appName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumesCreateWithBody(ctx context.Context, appName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumesCreateRequestWithBody(c.Server, appName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumesCreate(ctx context.Context, appName string, body VolumesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumesCreateRequest(c.Server, appName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumeDelete(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumeDeleteRequest(c.Server, appName, volumeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumesGetById(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumesGetByIdRequest(c.Server, appName, volumeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumesUpdateWithBody(ctx context.Context, appName string, volumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumesUpdateRequestWithBody(c.Server, appName, volumeId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumesUpdate(ctx context.Context, appName string, volumeId string, body VolumesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumesUpdateRequest(c.Server, appName, volumeId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumesExtendWithBody(ctx context.Context, appName string, volumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumesExtendRequestWithBody(c.Server, appName, volumeId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumesExtend(ctx context.Context, appName string, volumeId string, body VolumesExtendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumesExtendRequest(c.Server, appName, volumeId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VolumesListSnapshots(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVolumesListSnapshotsRequest(c.Server, appName, volumeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVolumeSnapshot(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVolumeSnapshotRequest(c.Server, appName, volumeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokensRequestKms(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokensRequestKmsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokensRequestOIDCWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokensRequestOIDCRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokensRequestOIDC(ctx context.Context, body TokensRequestOIDCJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokensRequestOIDCRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAppsListRequest generates requests for AppsList
func NewAppsListRequest(server string, params *AppsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org_slug", runtime.ParamLocationQuery, params.OrgSlug); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsCreateRequest calls the generic AppsCreate builder with application/json body
func NewAppsCreateRequest(server string, body AppsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewAppsCreateRequestWithBody generates requests for AppsCreate with any type of body
func NewAppsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppsDeleteRequest generates requests for AppsDelete
func NewAppsDeleteRequest(server string, appName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsShowRequest generates requests for AppsShow
func NewAppsShowRequest(server string, appName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesListRequest generates requests for MachinesList
func NewMachinesListRequest(server string, appName string, params *MachinesListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_deleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Summary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "summary", runtime.ParamLocationQuery, *params.Summary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesCreateRequest calls the generic MachinesCreate builder with application/json body
func NewMachinesCreateRequest(server string, appName string, body MachinesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMachinesCreateRequestWithBody(server, appName, "application/json", bodyReader)
}

// NewMachinesCreateRequestWithBody generates requests for MachinesCreate with any type of body
func NewMachinesCreateRequestWithBody(server string, appName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMachinesDeleteRequest generates requests for MachinesDelete
func NewMachinesDeleteRequest(server string, appName string, machineId string, params *MachinesDeleteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesShowRequest generates requests for MachinesShow
func NewMachinesShowRequest(server string, appName string, machineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesUpdateRequest calls the generic MachinesUpdate builder with application/json body
func NewMachinesUpdateRequest(server string, appName string, machineId string, body MachinesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMachinesUpdateRequestWithBody(server, appName, machineId, "application/json", bodyReader)
}

// NewMachinesUpdateRequestWithBody generates requests for MachinesUpdate with any type of body
func NewMachinesUpdateRequestWithBody(server string, appName string, machineId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMachinesCordonRequest generates requests for MachinesCordon
func NewMachinesCordonRequest(server string, appName string, machineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/cordon", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesListEventsRequest generates requests for MachinesListEvents
func NewMachinesListEventsRequest(server string, appName string, machineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/events", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesExecRequest calls the generic MachinesExec builder with application/json body
func NewMachinesExecRequest(server string, appName string, machineId string, body MachinesExecJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMachinesExecRequestWithBody(server, appName, machineId, "application/json", bodyReader)
}

// NewMachinesExecRequestWithBody generates requests for MachinesExec with any type of body
func NewMachinesExecRequestWithBody(server string, appName string, machineId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/exec", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMachinesReleaseLeaseRequest generates requests for MachinesReleaseLease
func NewMachinesReleaseLeaseRequest(server string, appName string, machineId string, params *MachinesReleaseLeaseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/lease", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "fly-machine-lease-nonce", runtime.ParamLocationHeader, params.FlyMachineLeaseNonce)
		if err != nil {
			return nil, err
		}

		req.Header.Set("fly-machine-lease-nonce", headerParam0)

	}

	return req, nil
}

// NewMachinesShowLeaseRequest generates requests for MachinesShowLease
func NewMachinesShowLeaseRequest(server string, appName string, machineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/lease", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesCreateLeaseRequest calls the generic MachinesCreateLease builder with application/json body
func NewMachinesCreateLeaseRequest(server string, appName string, machineId string, params *MachinesCreateLeaseParams, body MachinesCreateLeaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMachinesCreateLeaseRequestWithBody(server, appName, machineId, params, "application/json", bodyReader)
}

// NewMachinesCreateLeaseRequestWithBody generates requests for MachinesCreateLease with any type of body
func NewMachinesCreateLeaseRequestWithBody(server string, appName string, machineId string, params *MachinesCreateLeaseParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/lease", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.FlyMachineLeaseNonce != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "fly-machine-lease-nonce", runtime.ParamLocationHeader, *params.FlyMachineLeaseNonce)
			if err != nil {
				return nil, err
			}

			req.Header.Set("fly-machine-lease-nonce", headerParam0)
		}

	}

	return req, nil
}

// NewMachinesShowMetadataRequest generates requests for MachinesShowMetadata
func NewMachinesShowMetadataRequest(server string, appName string, machineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/metadata", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesDeleteMetadataRequest generates requests for MachinesDeleteMetadata
func NewMachinesDeleteMetadataRequest(server string, appName string, machineId string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/metadata/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesUpdateMetadataRequest generates requests for MachinesUpdateMetadata
func NewMachinesUpdateMetadataRequest(server string, appName string, machineId string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/metadata/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesListProcessesRequest generates requests for MachinesListProcesses
func NewMachinesListProcessesRequest(server string, appName string, machineId string, params *MachinesListProcessesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/ps", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesRestartRequest generates requests for MachinesRestart
func NewMachinesRestartRequest(server string, appName string, machineId string, params *MachinesRestartParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/restart", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Timeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeout", runtime.ParamLocationQuery, *params.Timeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Signal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "signal", runtime.ParamLocationQuery, *params.Signal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesSignalRequest calls the generic MachinesSignal builder with application/json body
func NewMachinesSignalRequest(server string, appName string, machineId string, body MachinesSignalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMachinesSignalRequestWithBody(server, appName, machineId, "application/json", bodyReader)
}

// NewMachinesSignalRequestWithBody generates requests for MachinesSignal with any type of body
func NewMachinesSignalRequestWithBody(server string, appName string, machineId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/signal", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMachinesStartRequest generates requests for MachinesStart
func NewMachinesStartRequest(server string, appName string, machineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/start", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesStopRequest calls the generic MachinesStop builder with application/json body
func NewMachinesStopRequest(server string, appName string, machineId string, body MachinesStopJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMachinesStopRequestWithBody(server, appName, machineId, "application/json", bodyReader)
}

// NewMachinesStopRequestWithBody generates requests for MachinesStop with any type of body
func NewMachinesStopRequestWithBody(server string, appName string, machineId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/stop", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMachinesSuspendRequest generates requests for MachinesSuspend
func NewMachinesSuspendRequest(server string, appName string, machineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/suspend", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesUncordonRequest generates requests for MachinesUncordon
func NewMachinesUncordonRequest(server string, appName string, machineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/uncordon", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesListVersionsRequest generates requests for MachinesListVersions
func NewMachinesListVersionsRequest(server string, appName string, machineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/versions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMachinesWaitRequest generates requests for MachinesWait
func NewMachinesWaitRequest(server string, appName string, machineId string, params *MachinesWaitParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "machine_id", runtime.ParamLocationPath, machineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/machines/%s/wait", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.InstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "instance_id", runtime.ParamLocationQuery, *params.InstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeout", runtime.ParamLocationQuery, *params.Timeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSecretsListRequest generates requests for SecretsList
func NewSecretsListRequest(server string, appName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/secrets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSecretDeleteRequest generates requests for SecretDelete
func NewSecretDeleteRequest(server string, appName string, secretLabel string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret_label", runtime.ParamLocationPath, secretLabel)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/secrets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSecretCreateRequest calls the generic SecretCreate builder with application/json body
func NewSecretCreateRequest(server string, appName string, secretLabel string, secretType string, body SecretCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSecretCreateRequestWithBody(server, appName, secretLabel, secretType, "application/json", bodyReader)
}

// NewSecretCreateRequestWithBody generates requests for SecretCreate with any type of body
func NewSecretCreateRequestWithBody(server string, appName string, secretLabel string, secretType string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret_label", runtime.ParamLocationPath, secretLabel)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "secret_type", runtime.ParamLocationPath, secretType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/secrets/%s/type/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSecretGenerateRequest generates requests for SecretGenerate
func NewSecretGenerateRequest(server string, appName string, secretLabel string, secretType string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret_label", runtime.ParamLocationPath, secretLabel)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "secret_type", runtime.ParamLocationPath, secretType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/secrets/%s/type/%s/generate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVolumesListRequest generates requests for VolumesList
func NewVolumesListRequest(server string, appName string, params *VolumesListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/volumes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Summary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "summary", runtime.ParamLocationQuery, *params.Summary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVolumesCreateRequest calls the generic VolumesCreate builder with application/json body
func NewVolumesCreateRequest(server string, appName string, body VolumesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVolumesCreateRequestWithBody(server, appName, "application/json", bodyReader)
}

// NewVolumesCreateRequestWithBody generates requests for VolumesCreate with any type of body
func NewVolumesCreateRequestWithBody(server string, appName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/volumes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVolumeDeleteRequest generates requests for VolumeDelete
func NewVolumeDeleteRequest(server string, appName string, volumeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "volume_id", runtime.ParamLocationPath, volumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/volumes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVolumesGetByIdRequest generates requests for VolumesGetById
func NewVolumesGetByIdRequest(server string, appName string, volumeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "volume_id", runtime.ParamLocationPath, volumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/volumes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVolumesUpdateRequest calls the generic VolumesUpdate builder with application/json body
func NewVolumesUpdateRequest(server string, appName string, volumeId string, body VolumesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVolumesUpdateRequestWithBody(server, appName, volumeId, "application/json", bodyReader)
}

// NewVolumesUpdateRequestWithBody generates requests for VolumesUpdate with any type of body
func NewVolumesUpdateRequestWithBody(server string, appName string, volumeId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "volume_id", runtime.ParamLocationPath, volumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/volumes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVolumesExtendRequest calls the generic VolumesExtend builder with application/json body
func NewVolumesExtendRequest(server string, appName string, volumeId string, body VolumesExtendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVolumesExtendRequestWithBody(server, appName, volumeId, "application/json", bodyReader)
}

// NewVolumesExtendRequestWithBody generates requests for VolumesExtend with any type of body
func NewVolumesExtendRequestWithBody(server string, appName string, volumeId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "volume_id", runtime.ParamLocationPath, volumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/volumes/%s/extend", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVolumesListSnapshotsRequest generates requests for VolumesListSnapshots
func NewVolumesListSnapshotsRequest(server string, appName string, volumeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "volume_id", runtime.ParamLocationPath, volumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/volumes/%s/snapshots", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVolumeSnapshotRequest generates requests for CreateVolumeSnapshot
func NewCreateVolumeSnapshotRequest(server string, appName string, volumeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_name", runtime.ParamLocationPath, appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "volume_id", runtime.ParamLocationPath, volumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/volumes/%s/snapshots", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTokensRequestKmsRequest generates requests for TokensRequestKms
func NewTokensRequestKmsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tokens/kms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTokensRequestOIDCRequest calls the generic TokensRequestOIDC builder with application/json body
func NewTokensRequestOIDCRequest(server string, body TokensRequestOIDCJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTokensRequestOIDCRequestWithBody(server, "application/json", bodyReader)
}

// NewTokensRequestOIDCRequestWithBody generates requests for TokensRequestOIDC with any type of body
func NewTokensRequestOIDCRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tokens/oidc")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AppsListWithResponse request
	AppsListWithResponse(ctx context.Context, params *AppsListParams, reqEditors ...RequestEditorFn) (*AppsListResponse, error)

	// AppsCreateWithBodyWithResponse request with any body
	AppsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppsCreateResponse, error)

	AppsCreateWithResponse(ctx context.Context, body AppsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AppsCreateResponse, error)

	// AppsDeleteWithResponse request
	AppsDeleteWithResponse(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*AppsDeleteResponse, error)

	// AppsShowWithResponse request
	AppsShowWithResponse(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*AppsShowResponse, error)

	// MachinesListWithResponse request
	MachinesListWithResponse(ctx context.Context, appName string, params *MachinesListParams, reqEditors ...RequestEditorFn) (*MachinesListResponse, error)

	// MachinesCreateWithBodyWithResponse request with any body
	MachinesCreateWithBodyWithResponse(ctx context.Context, appName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesCreateResponse, error)

	MachinesCreateWithResponse(ctx context.Context, appName string, body MachinesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesCreateResponse, error)

	// MachinesDeleteWithResponse request
	MachinesDeleteWithResponse(ctx context.Context, appName string, machineId string, params *MachinesDeleteParams, reqEditors ...RequestEditorFn) (*MachinesDeleteResponse, error)

	// MachinesShowWithResponse request
	MachinesShowWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesShowResponse, error)

	// MachinesUpdateWithBodyWithResponse request with any body
	MachinesUpdateWithBodyWithResponse(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesUpdateResponse, error)

	MachinesUpdateWithResponse(ctx context.Context, appName string, machineId string, body MachinesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesUpdateResponse, error)

	// MachinesCordonWithResponse request
	MachinesCordonWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesCordonResponse, error)

	// MachinesListEventsWithResponse request
	MachinesListEventsWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesListEventsResponse, error)

	// MachinesExecWithBodyWithResponse request with any body
	MachinesExecWithBodyWithResponse(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesExecResponse, error)

	MachinesExecWithResponse(ctx context.Context, appName string, machineId string, body MachinesExecJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesExecResponse, error)

	// MachinesReleaseLeaseWithResponse request
	MachinesReleaseLeaseWithResponse(ctx context.Context, appName string, machineId string, params *MachinesReleaseLeaseParams, reqEditors ...RequestEditorFn) (*MachinesReleaseLeaseResponse, error)

	// MachinesShowLeaseWithResponse request
	MachinesShowLeaseWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesShowLeaseResponse, error)

	// MachinesCreateLeaseWithBodyWithResponse request with any body
	MachinesCreateLeaseWithBodyWithResponse(ctx context.Context, appName string, machineId string, params *MachinesCreateLeaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesCreateLeaseResponse, error)

	MachinesCreateLeaseWithResponse(ctx context.Context, appName string, machineId string, params *MachinesCreateLeaseParams, body MachinesCreateLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesCreateLeaseResponse, error)

	// MachinesShowMetadataWithResponse request
	MachinesShowMetadataWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesShowMetadataResponse, error)

	// MachinesDeleteMetadataWithResponse request
	MachinesDeleteMetadataWithResponse(ctx context.Context, appName string, machineId string, key string, reqEditors ...RequestEditorFn) (*MachinesDeleteMetadataResponse, error)

	// MachinesUpdateMetadataWithResponse request
	MachinesUpdateMetadataWithResponse(ctx context.Context, appName string, machineId string, key string, reqEditors ...RequestEditorFn) (*MachinesUpdateMetadataResponse, error)

	// MachinesListProcessesWithResponse request
	MachinesListProcessesWithResponse(ctx context.Context, appName string, machineId string, params *MachinesListProcessesParams, reqEditors ...RequestEditorFn) (*MachinesListProcessesResponse, error)

	// MachinesRestartWithResponse request
	MachinesRestartWithResponse(ctx context.Context, appName string, machineId string, params *MachinesRestartParams, reqEditors ...RequestEditorFn) (*MachinesRestartResponse, error)

	// MachinesSignalWithBodyWithResponse request with any body
	MachinesSignalWithBodyWithResponse(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesSignalResponse, error)

	MachinesSignalWithResponse(ctx context.Context, appName string, machineId string, body MachinesSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesSignalResponse, error)

	// MachinesStartWithResponse request
	MachinesStartWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesStartResponse, error)

	// MachinesStopWithBodyWithResponse request with any body
	MachinesStopWithBodyWithResponse(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesStopResponse, error)

	MachinesStopWithResponse(ctx context.Context, appName string, machineId string, body MachinesStopJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesStopResponse, error)

	// MachinesSuspendWithResponse request
	MachinesSuspendWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesSuspendResponse, error)

	// MachinesUncordonWithResponse request
	MachinesUncordonWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesUncordonResponse, error)

	// MachinesListVersionsWithResponse request
	MachinesListVersionsWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesListVersionsResponse, error)

	// MachinesWaitWithResponse request
	MachinesWaitWithResponse(ctx context.Context, appName string, machineId string, params *MachinesWaitParams, reqEditors ...RequestEditorFn) (*MachinesWaitResponse, error)

	// SecretsListWithResponse request
	SecretsListWithResponse(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*SecretsListResponse, error)

	// SecretDeleteWithResponse request
	SecretDeleteWithResponse(ctx context.Context, appName string, secretLabel string, reqEditors ...RequestEditorFn) (*SecretDeleteResponse, error)

	// SecretCreateWithBodyWithResponse request with any body
	SecretCreateWithBodyWithResponse(ctx context.Context, appName string, secretLabel string, secretType string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SecretCreateResponse, error)

	SecretCreateWithResponse(ctx context.Context, appName string, secretLabel string, secretType string, body SecretCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SecretCreateResponse, error)

	// SecretGenerateWithResponse request
	SecretGenerateWithResponse(ctx context.Context, appName string, secretLabel string, secretType string, reqEditors ...RequestEditorFn) (*SecretGenerateResponse, error)

	// VolumesListWithResponse request
	VolumesListWithResponse(ctx context.Context, appName string, params *VolumesListParams, reqEditors ...RequestEditorFn) (*VolumesListResponse, error)

	// VolumesCreateWithBodyWithResponse request with any body
	VolumesCreateWithBodyWithResponse(ctx context.Context, appName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VolumesCreateResponse, error)

	VolumesCreateWithResponse(ctx context.Context, appName string, body VolumesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*VolumesCreateResponse, error)

	// VolumeDeleteWithResponse request
	VolumeDeleteWithResponse(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*VolumeDeleteResponse, error)

	// VolumesGetByIdWithResponse request
	VolumesGetByIdWithResponse(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*VolumesGetByIdResponse, error)

	// VolumesUpdateWithBodyWithResponse request with any body
	VolumesUpdateWithBodyWithResponse(ctx context.Context, appName string, volumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VolumesUpdateResponse, error)

	VolumesUpdateWithResponse(ctx context.Context, appName string, volumeId string, body VolumesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*VolumesUpdateResponse, error)

	// VolumesExtendWithBodyWithResponse request with any body
	VolumesExtendWithBodyWithResponse(ctx context.Context, appName string, volumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VolumesExtendResponse, error)

	VolumesExtendWithResponse(ctx context.Context, appName string, volumeId string, body VolumesExtendJSONRequestBody, reqEditors ...RequestEditorFn) (*VolumesExtendResponse, error)

	// VolumesListSnapshotsWithResponse request
	VolumesListSnapshotsWithResponse(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*VolumesListSnapshotsResponse, error)

	// CreateVolumeSnapshotWithResponse request
	CreateVolumeSnapshotWithResponse(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*CreateVolumeSnapshotResponse, error)

	// TokensRequestKmsWithResponse request
	TokensRequestKmsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TokensRequestKmsResponse, error)

	// TokensRequestOIDCWithBodyWithResponse request with any body
	TokensRequestOIDCWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokensRequestOIDCResponse, error)

	TokensRequestOIDCWithResponse(ctx context.Context, body TokensRequestOIDCJSONRequestBody, reqEditors ...RequestEditorFn) (*TokensRequestOIDCResponse, error)
}

type AppsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAppsResponse
}

// Status returns HTTPResponse.Status
func (r AppsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r AppsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AppsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
}

// Status returns HTTPResponse.Status
func (r AppsShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Machine
}

// Status returns HTTPResponse.Status
func (r MachinesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Machine
}

// Status returns HTTPResponse.Status
func (r MachinesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MachinesDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Machine
}

// Status returns HTTPResponse.Status
func (r MachinesShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Machine
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MachinesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesCordonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MachinesCordonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesCordonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesListEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MachineEvent
}

// Status returns HTTPResponse.Status
func (r MachinesListEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesListEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesExecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Flydv1ExecResponse
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MachinesExecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesExecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesReleaseLeaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MachinesReleaseLeaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesReleaseLeaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesShowLeaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Lease
}

// Status returns HTTPResponse.Status
func (r MachinesShowLeaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesShowLeaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesCreateLeaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Lease
}

// Status returns HTTPResponse.Status
func (r MachinesCreateLeaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesCreateLeaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesShowMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]string
}

// Status returns HTTPResponse.Status
func (r MachinesShowMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesShowMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesDeleteMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MachinesDeleteMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesDeleteMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesUpdateMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MachinesUpdateMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesUpdateMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesListProcessesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ProcessStat
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MachinesListProcessesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesListProcessesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesRestartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MachinesRestartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesRestartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesSignalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MachinesSignalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesSignalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MachinesStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesStopResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MachinesStopResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesStopResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesSuspendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MachinesSuspendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesSuspendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesUncordonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MachinesUncordonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesUncordonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesListVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MachineVersion
}

// Status returns HTTPResponse.Status
func (r MachinesListVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesListVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MachinesWaitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r MachinesWaitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MachinesWaitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SecretsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ListSecret
}

// Status returns HTTPResponse.Status
func (r SecretsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SecretsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SecretDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SecretDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SecretDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SecretCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SecretCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SecretCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SecretGenerateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SecretGenerateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SecretGenerateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VolumesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Volume
}

// Status returns HTTPResponse.Status
func (r VolumesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VolumesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VolumesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
}

// Status returns HTTPResponse.Status
func (r VolumesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VolumesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VolumeDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
}

// Status returns HTTPResponse.Status
func (r VolumeDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VolumeDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VolumesGetByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
}

// Status returns HTTPResponse.Status
func (r VolumesGetByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VolumesGetByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VolumesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Volume
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r VolumesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VolumesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VolumesExtendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExtendVolumeResponse
}

// Status returns HTTPResponse.Status
func (r VolumesExtendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VolumesExtendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VolumesListSnapshotsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]VolumeSnapshot
}

// Status returns HTTPResponse.Status
func (r VolumesListSnapshotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VolumesListSnapshotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVolumeSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateVolumeSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVolumeSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TokensRequestKmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r TokensRequestKmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TokensRequestKmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TokensRequestOIDCResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TokensRequestOIDCResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TokensRequestOIDCResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AppsListWithResponse request returning *AppsListResponse
func (c *ClientWithResponses) AppsListWithResponse(ctx context.Context, params *AppsListParams, reqEditors ...RequestEditorFn) (*AppsListResponse, error) {
	rsp, err := c.AppsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsListResponse(rsp)
}

// AppsCreateWithBodyWithResponse request with arbitrary body returning *AppsCreateResponse
func (c *ClientWithResponses) AppsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppsCreateResponse, error) {
	rsp, err := c.AppsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsCreateResponse(rsp)
}

func (c *ClientWithResponses) AppsCreateWithResponse(ctx context.Context, body AppsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AppsCreateResponse, error) {
	rsp, err := c.AppsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsCreateResponse(rsp)
}

// AppsDeleteWithResponse request returning *AppsDeleteResponse
func (c *ClientWithResponses) AppsDeleteWithResponse(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*AppsDeleteResponse, error) {
	rsp, err := c.AppsDelete(ctx, appName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsDeleteResponse(rsp)
}

// AppsShowWithResponse request returning *AppsShowResponse
func (c *ClientWithResponses) AppsShowWithResponse(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*AppsShowResponse, error) {
	rsp, err := c.AppsShow(ctx, appName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsShowResponse(rsp)
}

// MachinesListWithResponse request returning *MachinesListResponse
func (c *ClientWithResponses) MachinesListWithResponse(ctx context.Context, appName string, params *MachinesListParams, reqEditors ...RequestEditorFn) (*MachinesListResponse, error) {
	rsp, err := c.MachinesList(ctx, appName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesListResponse(rsp)
}

// MachinesCreateWithBodyWithResponse request with arbitrary body returning *MachinesCreateResponse
func (c *ClientWithResponses) MachinesCreateWithBodyWithResponse(ctx context.Context, appName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesCreateResponse, error) {
	rsp, err := c.MachinesCreateWithBody(ctx, appName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesCreateResponse(rsp)
}

func (c *ClientWithResponses) MachinesCreateWithResponse(ctx context.Context, appName string, body MachinesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesCreateResponse, error) {
	rsp, err := c.MachinesCreate(ctx, appName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesCreateResponse(rsp)
}

// MachinesDeleteWithResponse request returning *MachinesDeleteResponse
func (c *ClientWithResponses) MachinesDeleteWithResponse(ctx context.Context, appName string, machineId string, params *MachinesDeleteParams, reqEditors ...RequestEditorFn) (*MachinesDeleteResponse, error) {
	rsp, err := c.MachinesDelete(ctx, appName, machineId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesDeleteResponse(rsp)
}

// MachinesShowWithResponse request returning *MachinesShowResponse
func (c *ClientWithResponses) MachinesShowWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesShowResponse, error) {
	rsp, err := c.MachinesShow(ctx, appName, machineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesShowResponse(rsp)
}

// MachinesUpdateWithBodyWithResponse request with arbitrary body returning *MachinesUpdateResponse
func (c *ClientWithResponses) MachinesUpdateWithBodyWithResponse(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesUpdateResponse, error) {
	rsp, err := c.MachinesUpdateWithBody(ctx, appName, machineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesUpdateResponse(rsp)
}

func (c *ClientWithResponses) MachinesUpdateWithResponse(ctx context.Context, appName string, machineId string, body MachinesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesUpdateResponse, error) {
	rsp, err := c.MachinesUpdate(ctx, appName, machineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesUpdateResponse(rsp)
}

// MachinesCordonWithResponse request returning *MachinesCordonResponse
func (c *ClientWithResponses) MachinesCordonWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesCordonResponse, error) {
	rsp, err := c.MachinesCordon(ctx, appName, machineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesCordonResponse(rsp)
}

// MachinesListEventsWithResponse request returning *MachinesListEventsResponse
func (c *ClientWithResponses) MachinesListEventsWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesListEventsResponse, error) {
	rsp, err := c.MachinesListEvents(ctx, appName, machineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesListEventsResponse(rsp)
}

// MachinesExecWithBodyWithResponse request with arbitrary body returning *MachinesExecResponse
func (c *ClientWithResponses) MachinesExecWithBodyWithResponse(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesExecResponse, error) {
	rsp, err := c.MachinesExecWithBody(ctx, appName, machineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesExecResponse(rsp)
}

func (c *ClientWithResponses) MachinesExecWithResponse(ctx context.Context, appName string, machineId string, body MachinesExecJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesExecResponse, error) {
	rsp, err := c.MachinesExec(ctx, appName, machineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesExecResponse(rsp)
}

// MachinesReleaseLeaseWithResponse request returning *MachinesReleaseLeaseResponse
func (c *ClientWithResponses) MachinesReleaseLeaseWithResponse(ctx context.Context, appName string, machineId string, params *MachinesReleaseLeaseParams, reqEditors ...RequestEditorFn) (*MachinesReleaseLeaseResponse, error) {
	rsp, err := c.MachinesReleaseLease(ctx, appName, machineId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesReleaseLeaseResponse(rsp)
}

// MachinesShowLeaseWithResponse request returning *MachinesShowLeaseResponse
func (c *ClientWithResponses) MachinesShowLeaseWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesShowLeaseResponse, error) {
	rsp, err := c.MachinesShowLease(ctx, appName, machineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesShowLeaseResponse(rsp)
}

// MachinesCreateLeaseWithBodyWithResponse request with arbitrary body returning *MachinesCreateLeaseResponse
func (c *ClientWithResponses) MachinesCreateLeaseWithBodyWithResponse(ctx context.Context, appName string, machineId string, params *MachinesCreateLeaseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesCreateLeaseResponse, error) {
	rsp, err := c.MachinesCreateLeaseWithBody(ctx, appName, machineId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesCreateLeaseResponse(rsp)
}

func (c *ClientWithResponses) MachinesCreateLeaseWithResponse(ctx context.Context, appName string, machineId string, params *MachinesCreateLeaseParams, body MachinesCreateLeaseJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesCreateLeaseResponse, error) {
	rsp, err := c.MachinesCreateLease(ctx, appName, machineId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesCreateLeaseResponse(rsp)
}

// MachinesShowMetadataWithResponse request returning *MachinesShowMetadataResponse
func (c *ClientWithResponses) MachinesShowMetadataWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesShowMetadataResponse, error) {
	rsp, err := c.MachinesShowMetadata(ctx, appName, machineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesShowMetadataResponse(rsp)
}

// MachinesDeleteMetadataWithResponse request returning *MachinesDeleteMetadataResponse
func (c *ClientWithResponses) MachinesDeleteMetadataWithResponse(ctx context.Context, appName string, machineId string, key string, reqEditors ...RequestEditorFn) (*MachinesDeleteMetadataResponse, error) {
	rsp, err := c.MachinesDeleteMetadata(ctx, appName, machineId, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesDeleteMetadataResponse(rsp)
}

// MachinesUpdateMetadataWithResponse request returning *MachinesUpdateMetadataResponse
func (c *ClientWithResponses) MachinesUpdateMetadataWithResponse(ctx context.Context, appName string, machineId string, key string, reqEditors ...RequestEditorFn) (*MachinesUpdateMetadataResponse, error) {
	rsp, err := c.MachinesUpdateMetadata(ctx, appName, machineId, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesUpdateMetadataResponse(rsp)
}

// MachinesListProcessesWithResponse request returning *MachinesListProcessesResponse
func (c *ClientWithResponses) MachinesListProcessesWithResponse(ctx context.Context, appName string, machineId string, params *MachinesListProcessesParams, reqEditors ...RequestEditorFn) (*MachinesListProcessesResponse, error) {
	rsp, err := c.MachinesListProcesses(ctx, appName, machineId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesListProcessesResponse(rsp)
}

// MachinesRestartWithResponse request returning *MachinesRestartResponse
func (c *ClientWithResponses) MachinesRestartWithResponse(ctx context.Context, appName string, machineId string, params *MachinesRestartParams, reqEditors ...RequestEditorFn) (*MachinesRestartResponse, error) {
	rsp, err := c.MachinesRestart(ctx, appName, machineId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesRestartResponse(rsp)
}

// MachinesSignalWithBodyWithResponse request with arbitrary body returning *MachinesSignalResponse
func (c *ClientWithResponses) MachinesSignalWithBodyWithResponse(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesSignalResponse, error) {
	rsp, err := c.MachinesSignalWithBody(ctx, appName, machineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesSignalResponse(rsp)
}

func (c *ClientWithResponses) MachinesSignalWithResponse(ctx context.Context, appName string, machineId string, body MachinesSignalJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesSignalResponse, error) {
	rsp, err := c.MachinesSignal(ctx, appName, machineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesSignalResponse(rsp)
}

// MachinesStartWithResponse request returning *MachinesStartResponse
func (c *ClientWithResponses) MachinesStartWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesStartResponse, error) {
	rsp, err := c.MachinesStart(ctx, appName, machineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesStartResponse(rsp)
}

// MachinesStopWithBodyWithResponse request with arbitrary body returning *MachinesStopResponse
func (c *ClientWithResponses) MachinesStopWithBodyWithResponse(ctx context.Context, appName string, machineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MachinesStopResponse, error) {
	rsp, err := c.MachinesStopWithBody(ctx, appName, machineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesStopResponse(rsp)
}

func (c *ClientWithResponses) MachinesStopWithResponse(ctx context.Context, appName string, machineId string, body MachinesStopJSONRequestBody, reqEditors ...RequestEditorFn) (*MachinesStopResponse, error) {
	rsp, err := c.MachinesStop(ctx, appName, machineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesStopResponse(rsp)
}

// MachinesSuspendWithResponse request returning *MachinesSuspendResponse
func (c *ClientWithResponses) MachinesSuspendWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesSuspendResponse, error) {
	rsp, err := c.MachinesSuspend(ctx, appName, machineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesSuspendResponse(rsp)
}

// MachinesUncordonWithResponse request returning *MachinesUncordonResponse
func (c *ClientWithResponses) MachinesUncordonWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesUncordonResponse, error) {
	rsp, err := c.MachinesUncordon(ctx, appName, machineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesUncordonResponse(rsp)
}

// MachinesListVersionsWithResponse request returning *MachinesListVersionsResponse
func (c *ClientWithResponses) MachinesListVersionsWithResponse(ctx context.Context, appName string, machineId string, reqEditors ...RequestEditorFn) (*MachinesListVersionsResponse, error) {
	rsp, err := c.MachinesListVersions(ctx, appName, machineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesListVersionsResponse(rsp)
}

// MachinesWaitWithResponse request returning *MachinesWaitResponse
func (c *ClientWithResponses) MachinesWaitWithResponse(ctx context.Context, appName string, machineId string, params *MachinesWaitParams, reqEditors ...RequestEditorFn) (*MachinesWaitResponse, error) {
	rsp, err := c.MachinesWait(ctx, appName, machineId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMachinesWaitResponse(rsp)
}

// SecretsListWithResponse request returning *SecretsListResponse
func (c *ClientWithResponses) SecretsListWithResponse(ctx context.Context, appName string, reqEditors ...RequestEditorFn) (*SecretsListResponse, error) {
	rsp, err := c.SecretsList(ctx, appName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSecretsListResponse(rsp)
}

// SecretDeleteWithResponse request returning *SecretDeleteResponse
func (c *ClientWithResponses) SecretDeleteWithResponse(ctx context.Context, appName string, secretLabel string, reqEditors ...RequestEditorFn) (*SecretDeleteResponse, error) {
	rsp, err := c.SecretDelete(ctx, appName, secretLabel, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSecretDeleteResponse(rsp)
}

// SecretCreateWithBodyWithResponse request with arbitrary body returning *SecretCreateResponse
func (c *ClientWithResponses) SecretCreateWithBodyWithResponse(ctx context.Context, appName string, secretLabel string, secretType string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SecretCreateResponse, error) {
	rsp, err := c.SecretCreateWithBody(ctx, appName, secretLabel, secretType, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSecretCreateResponse(rsp)
}

func (c *ClientWithResponses) SecretCreateWithResponse(ctx context.Context, appName string, secretLabel string, secretType string, body SecretCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SecretCreateResponse, error) {
	rsp, err := c.SecretCreate(ctx, appName, secretLabel, secretType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSecretCreateResponse(rsp)
}

// SecretGenerateWithResponse request returning *SecretGenerateResponse
func (c *ClientWithResponses) SecretGenerateWithResponse(ctx context.Context, appName string, secretLabel string, secretType string, reqEditors ...RequestEditorFn) (*SecretGenerateResponse, error) {
	rsp, err := c.SecretGenerate(ctx, appName, secretLabel, secretType, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSecretGenerateResponse(rsp)
}

// VolumesListWithResponse request returning *VolumesListResponse
func (c *ClientWithResponses) VolumesListWithResponse(ctx context.Context, appName string, params *VolumesListParams, reqEditors ...RequestEditorFn) (*VolumesListResponse, error) {
	rsp, err := c.VolumesList(ctx, appName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumesListResponse(rsp)
}

// VolumesCreateWithBodyWithResponse request with arbitrary body returning *VolumesCreateResponse
func (c *ClientWithResponses) VolumesCreateWithBodyWithResponse(ctx context.Context, appName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VolumesCreateResponse, error) {
	rsp, err := c.VolumesCreateWithBody(ctx, appName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumesCreateResponse(rsp)
}

func (c *ClientWithResponses) VolumesCreateWithResponse(ctx context.Context, appName string, body VolumesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*VolumesCreateResponse, error) {
	rsp, err := c.VolumesCreate(ctx, appName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumesCreateResponse(rsp)
}

// VolumeDeleteWithResponse request returning *VolumeDeleteResponse
func (c *ClientWithResponses) VolumeDeleteWithResponse(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*VolumeDeleteResponse, error) {
	rsp, err := c.VolumeDelete(ctx, appName, volumeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumeDeleteResponse(rsp)
}

// VolumesGetByIdWithResponse request returning *VolumesGetByIdResponse
func (c *ClientWithResponses) VolumesGetByIdWithResponse(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*VolumesGetByIdResponse, error) {
	rsp, err := c.VolumesGetById(ctx, appName, volumeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumesGetByIdResponse(rsp)
}

// VolumesUpdateWithBodyWithResponse request with arbitrary body returning *VolumesUpdateResponse
func (c *ClientWithResponses) VolumesUpdateWithBodyWithResponse(ctx context.Context, appName string, volumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VolumesUpdateResponse, error) {
	rsp, err := c.VolumesUpdateWithBody(ctx, appName, volumeId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumesUpdateResponse(rsp)
}

func (c *ClientWithResponses) VolumesUpdateWithResponse(ctx context.Context, appName string, volumeId string, body VolumesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*VolumesUpdateResponse, error) {
	rsp, err := c.VolumesUpdate(ctx, appName, volumeId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumesUpdateResponse(rsp)
}

// VolumesExtendWithBodyWithResponse request with arbitrary body returning *VolumesExtendResponse
func (c *ClientWithResponses) VolumesExtendWithBodyWithResponse(ctx context.Context, appName string, volumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VolumesExtendResponse, error) {
	rsp, err := c.VolumesExtendWithBody(ctx, appName, volumeId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumesExtendResponse(rsp)
}

func (c *ClientWithResponses) VolumesExtendWithResponse(ctx context.Context, appName string, volumeId string, body VolumesExtendJSONRequestBody, reqEditors ...RequestEditorFn) (*VolumesExtendResponse, error) {
	rsp, err := c.VolumesExtend(ctx, appName, volumeId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumesExtendResponse(rsp)
}

// VolumesListSnapshotsWithResponse request returning *VolumesListSnapshotsResponse
func (c *ClientWithResponses) VolumesListSnapshotsWithResponse(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*VolumesListSnapshotsResponse, error) {
	rsp, err := c.VolumesListSnapshots(ctx, appName, volumeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVolumesListSnapshotsResponse(rsp)
}

// CreateVolumeSnapshotWithResponse request returning *CreateVolumeSnapshotResponse
func (c *ClientWithResponses) CreateVolumeSnapshotWithResponse(ctx context.Context, appName string, volumeId string, reqEditors ...RequestEditorFn) (*CreateVolumeSnapshotResponse, error) {
	rsp, err := c.CreateVolumeSnapshot(ctx, appName, volumeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVolumeSnapshotResponse(rsp)
}

// TokensRequestKmsWithResponse request returning *TokensRequestKmsResponse
func (c *ClientWithResponses) TokensRequestKmsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TokensRequestKmsResponse, error) {
	rsp, err := c.TokensRequestKms(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokensRequestKmsResponse(rsp)
}

// TokensRequestOIDCWithBodyWithResponse request with arbitrary body returning *TokensRequestOIDCResponse
func (c *ClientWithResponses) TokensRequestOIDCWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokensRequestOIDCResponse, error) {
	rsp, err := c.TokensRequestOIDCWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokensRequestOIDCResponse(rsp)
}

func (c *ClientWithResponses) TokensRequestOIDCWithResponse(ctx context.Context, body TokensRequestOIDCJSONRequestBody, reqEditors ...RequestEditorFn) (*TokensRequestOIDCResponse, error) {
	rsp, err := c.TokensRequestOIDC(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokensRequestOIDCResponse(rsp)
}

// ParseAppsListResponse parses an HTTP response from a AppsListWithResponse call
func ParseAppsListResponse(rsp *http.Response) (*AppsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAppsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAppsCreateResponse parses an HTTP response from a AppsCreateWithResponse call
func ParseAppsCreateResponse(rsp *http.Response) (*AppsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAppsDeleteResponse parses an HTTP response from a AppsDeleteWithResponse call
func ParseAppsDeleteResponse(rsp *http.Response) (*AppsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAppsShowResponse parses an HTTP response from a AppsShowWithResponse call
func ParseAppsShowResponse(rsp *http.Response) (*AppsShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMachinesListResponse parses an HTTP response from a MachinesListWithResponse call
func ParseMachinesListResponse(rsp *http.Response) (*MachinesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Machine
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMachinesCreateResponse parses an HTTP response from a MachinesCreateWithResponse call
func ParseMachinesCreateResponse(rsp *http.Response) (*MachinesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Machine
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMachinesDeleteResponse parses an HTTP response from a MachinesDeleteWithResponse call
func ParseMachinesDeleteResponse(rsp *http.Response) (*MachinesDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMachinesShowResponse parses an HTTP response from a MachinesShowWithResponse call
func ParseMachinesShowResponse(rsp *http.Response) (*MachinesShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Machine
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMachinesUpdateResponse parses an HTTP response from a MachinesUpdateWithResponse call
func ParseMachinesUpdateResponse(rsp *http.Response) (*MachinesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Machine
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseMachinesCordonResponse parses an HTTP response from a MachinesCordonWithResponse call
func ParseMachinesCordonResponse(rsp *http.Response) (*MachinesCordonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesCordonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMachinesListEventsResponse parses an HTTP response from a MachinesListEventsWithResponse call
func ParseMachinesListEventsResponse(rsp *http.Response) (*MachinesListEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesListEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MachineEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMachinesExecResponse parses an HTTP response from a MachinesExecWithResponse call
func ParseMachinesExecResponse(rsp *http.Response) (*MachinesExecResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesExecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Flydv1ExecResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case rsp.StatusCode == 200:
	// Content-type (application/octet-stream) unsupported

	case rsp.StatusCode == 400:
		// Content-type (application/octet-stream) unsupported

	}

	return response, nil
}

// ParseMachinesReleaseLeaseResponse parses an HTTP response from a MachinesReleaseLeaseWithResponse call
func ParseMachinesReleaseLeaseResponse(rsp *http.Response) (*MachinesReleaseLeaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesReleaseLeaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMachinesShowLeaseResponse parses an HTTP response from a MachinesShowLeaseWithResponse call
func ParseMachinesShowLeaseResponse(rsp *http.Response) (*MachinesShowLeaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesShowLeaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Lease
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMachinesCreateLeaseResponse parses an HTTP response from a MachinesCreateLeaseWithResponse call
func ParseMachinesCreateLeaseResponse(rsp *http.Response) (*MachinesCreateLeaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesCreateLeaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Lease
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMachinesShowMetadataResponse parses an HTTP response from a MachinesShowMetadataWithResponse call
func ParseMachinesShowMetadataResponse(rsp *http.Response) (*MachinesShowMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesShowMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMachinesDeleteMetadataResponse parses an HTTP response from a MachinesDeleteMetadataWithResponse call
func ParseMachinesDeleteMetadataResponse(rsp *http.Response) (*MachinesDeleteMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesDeleteMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMachinesUpdateMetadataResponse parses an HTTP response from a MachinesUpdateMetadataWithResponse call
func ParseMachinesUpdateMetadataResponse(rsp *http.Response) (*MachinesUpdateMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesUpdateMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseMachinesListProcessesResponse parses an HTTP response from a MachinesListProcessesWithResponse call
func ParseMachinesListProcessesResponse(rsp *http.Response) (*MachinesListProcessesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesListProcessesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ProcessStat
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseMachinesRestartResponse parses an HTTP response from a MachinesRestartWithResponse call
func ParseMachinesRestartResponse(rsp *http.Response) (*MachinesRestartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesRestartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseMachinesSignalResponse parses an HTTP response from a MachinesSignalWithResponse call
func ParseMachinesSignalResponse(rsp *http.Response) (*MachinesSignalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesSignalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseMachinesStartResponse parses an HTTP response from a MachinesStartWithResponse call
func ParseMachinesStartResponse(rsp *http.Response) (*MachinesStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMachinesStopResponse parses an HTTP response from a MachinesStopWithResponse call
func ParseMachinesStopResponse(rsp *http.Response) (*MachinesStopResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesStopResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseMachinesSuspendResponse parses an HTTP response from a MachinesSuspendWithResponse call
func ParseMachinesSuspendResponse(rsp *http.Response) (*MachinesSuspendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesSuspendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMachinesUncordonResponse parses an HTTP response from a MachinesUncordonWithResponse call
func ParseMachinesUncordonResponse(rsp *http.Response) (*MachinesUncordonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesUncordonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMachinesListVersionsResponse parses an HTTP response from a MachinesListVersionsWithResponse call
func ParseMachinesListVersionsResponse(rsp *http.Response) (*MachinesListVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesListVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MachineVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMachinesWaitResponse parses an HTTP response from a MachinesWaitWithResponse call
func ParseMachinesWaitResponse(rsp *http.Response) (*MachinesWaitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MachinesWaitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSecretsListResponse parses an HTTP response from a SecretsListWithResponse call
func ParseSecretsListResponse(rsp *http.Response) (*SecretsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SecretsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ListSecret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSecretDeleteResponse parses an HTTP response from a SecretDeleteWithResponse call
func ParseSecretDeleteResponse(rsp *http.Response) (*SecretDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SecretDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSecretCreateResponse parses an HTTP response from a SecretCreateWithResponse call
func ParseSecretCreateResponse(rsp *http.Response) (*SecretCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SecretCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSecretGenerateResponse parses an HTTP response from a SecretGenerateWithResponse call
func ParseSecretGenerateResponse(rsp *http.Response) (*SecretGenerateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SecretGenerateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseVolumesListResponse parses an HTTP response from a VolumesListWithResponse call
func ParseVolumesListResponse(rsp *http.Response) (*VolumesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VolumesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVolumesCreateResponse parses an HTTP response from a VolumesCreateWithResponse call
func ParseVolumesCreateResponse(rsp *http.Response) (*VolumesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VolumesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVolumeDeleteResponse parses an HTTP response from a VolumeDeleteWithResponse call
func ParseVolumeDeleteResponse(rsp *http.Response) (*VolumeDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VolumeDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVolumesGetByIdResponse parses an HTTP response from a VolumesGetByIdWithResponse call
func ParseVolumesGetByIdResponse(rsp *http.Response) (*VolumesGetByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VolumesGetByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVolumesUpdateResponse parses an HTTP response from a VolumesUpdateWithResponse call
func ParseVolumesUpdateResponse(rsp *http.Response) (*VolumesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VolumesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Volume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseVolumesExtendResponse parses an HTTP response from a VolumesExtendWithResponse call
func ParseVolumesExtendResponse(rsp *http.Response) (*VolumesExtendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VolumesExtendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExtendVolumeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVolumesListSnapshotsResponse parses an HTTP response from a VolumesListSnapshotsWithResponse call
func ParseVolumesListSnapshotsResponse(rsp *http.Response) (*VolumesListSnapshotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VolumesListSnapshotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []VolumeSnapshot
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVolumeSnapshotResponse parses an HTTP response from a CreateVolumeSnapshotWithResponse call
func ParseCreateVolumeSnapshotResponse(rsp *http.Response) (*CreateVolumeSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVolumeSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTokensRequestKmsResponse parses an HTTP response from a TokensRequestKmsWithResponse call
func ParseTokensRequestKmsResponse(rsp *http.Response) (*TokensRequestKmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TokensRequestKmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTokensRequestOIDCResponse parses an HTTP response from a TokensRequestOIDCWithResponse call
func ParseTokensRequestOIDCResponse(rsp *http.Response) (*TokensRequestOIDCResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TokensRequestOIDCResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}
